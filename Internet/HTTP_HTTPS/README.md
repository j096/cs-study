# HTTP vs HTTPS
- Hyper Text Transfer Protocol: 서버/클라이언트 모델에서 텍스트, 이미지, 동영상 등의 데이터를 주고 받기 위한 프로토콜
- 기본 80 포트, TCP/IP, stateless, 평문데이터 전송
## stateless (무상태성)
- HTTP는 요청 메시지를 보내기 직전까지 대상 컴퓨터가 연결 가능한지, 메시지를 응답할 수 있는 상태인지 알 방법이 없다.
- 모든 HTTP 메시지는 요청과 응답이 일대일로 대응되어야 하므로 요청을 받은 서버는 반드시 응답을 보내야만 한다. 클라이언트 항상 자신이 보낸 요청이 실패했는지, 정상적으로 왔는지 알 수 있어서 로직이 단순해지는 장점이 있다.
- 클라이언트는 서버로 HTTP 요청을 보내기 직전까지 실제로 서버가 동작하는지 알 방법이 없다. 따라서 클라이언트 어떤 이유로든 서버로부터 일정 시간 안에 HTTP 응답을 받지 못하면 타임아웃으로 요청을 실패한 것으로 처리한다.
### stateful과 비교
- TCP(Transmission Control Protocol): 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 네트워크 프로토콜이다. TCP는 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장해준다. 명시적으로 연결을 닫기 전까지 계속 메시지를 주고받는다. 텍스트가 아닌 바이너리 데이터를 사용한다.
- HTTP는 TCP 프로토콜 기반에 텍스트 기반의 HTTP 헤더와 메시지까지 사용하기 때문에 패킷 크기가 상대적으로 크다. (TCP가 더 빠름)
- HTTP는 각 요청이 소켓 1개를 점유하고 TCP는 모든 요청이 소켓 1개를 사용하기 때문에 모든 요청이 1개의 소켓안에서 섞이게 된다. 그래서 별도로 요청 ID와 같은 식별자를 사용한다.
```
HTTP
1) 클라이언트 -> 서버: HTTP 요청
2) 서버 -> 클라이언트: HTTP 응답 & 응답 데이터

TCP
1) 클라이언트 -> 서버: SYN
2) 서버 -> 클라이언트: SYN/ACK
3) 클라이언트 -> 서버: ACK
4) 클라이언트 -> 서버: HTTP 요청
5) 서버 -> 클라이언트: HTTP 응답 & 응답 데이터
6) 클라이언트 -> 서버: ACK
7) 서버 -> 클라이언트: FIN
8) 클라이언트 -> 서버: FIN
```
## 요청 메서드 (GET, POST, DELETE, PUT)
- 요청의 형태를 정의하는 키워드.
### GET
- 웹 브라우저가 서버에 웹 페이지를 요청할 때 사용.
- 읽기 요청에 해당하므로 메시지 바디를 넣을 수 없다.
- 요청 주소에 ``?``와  ``&`` 문자를 구분자로 사용하는 쿼리 파라미터를 추가할 수 있다.
### POST
- 클라이언트에서 서버로 데이터가 포함된 요청을 보낼 때 사용.
- 일반적으로 로그인이나 주문 요청 과정 등에서 사용.
### DELETE & PUT
- DELETE는 데이터 삭제, PUT은 이미 존재하는 데이터의 업데이트 요청을 의미하며 기술적으로는 POST와 큰 차이가 없다.

## URL (Uniform Resource Locator)
- HTTP에서 통신할 대상 컴퓨터를 식별할 때 사용.
- ex) ``naver.com`` ``google.com``
- 실제로 통신할 때는 IP를 사용하기 때문에 통신을 위해서는 URL을 IP 주소로 변환하는 작업이 필요하다. 주소 변환 작업은 DNS (Domain Name System) 을 통해 할 수 있다.
## HTTP 버전
- 1.1 버전은 1.0 버전보다 효율적인 연결을 위해 소켓 재사용을 요청하는 keep-alive 헤더 추가와 언어 및 인코딩 지원을 위한 헤더 등이 추가됐다. 1.1 버전은 하나의 요청에 하나의 응답만 보낼 수 있다.
- 한 번의 요청에 수십 개의 응답을 병렬로 보낼 수 있도록 개선하고 불필요한 오버헤드를 제거한 것이 2.0 버전이다.
## 세션과 쿠키
- HTTP는 stateless 이기 때문에 서버는 클라이언트가 이전에 어떤 요청을 보냈는지 구분할 수 없다. 즉, 서버는 각 요청이 새로운 클라이언트로부터 온 것인지, 기존에 연결을 맺었던 클라이언트인지 알 수 없다. 모든 요청이 독립적으로 소켓 1개를 사용하고, 모든 요청은 다른 요청과 독립적이기 때문이다. 때문에 HTTP 웹 서버는 쿠키와 세션 ID를 사용해 클라이언트를 구분한다. 쿠키를 사용하면 클라이언트가 새 요청을 보낸 것인지, 이전에 보낸 요청이 있었는지 구분할 수 있다.
- 세션 ID를 키로 하는 자료구조 컨테이너(맵 또는 해시 맵)를 사용 중이라면, LRU 알고리즘을 사용해 만료 시간이 지난 컨테이너 데이터를 지워야한다.
### 스티키 세션 (Sticky Session)
- 로드밸런스: 사용자가 접속했을 때 부하가 가장 적은 웹 서버로 연결해주고 동작하지 않는 서버를 발견하면 서버 목록에서 자동으로 제외한다.
- 사용자가 웹 페이지를 요청할 때마다 실제로 접속하게 되는 서버가 바뀌게 되면 쿠키나 세션 정보가 사라질 수도 있다.
- 스티키 세션은 이러한 구조를 보완하기 위한 기능이다. 하나의 브라우저는 하나의 서버에만 접속하게 된다.
## RESTful API vs SOAP
- REST: REpresentational State Transfer
- 서버와 클라이언트가 메시지를 주고받을 때 가장 많이 사용하는 통신 규격.
- 요청 주소와 메서드(GET, POST 등), JSON 규격을 이용하여 API를 정의한다.
```
메서드
- POST: 새로운 객체를 생성할 때 사용
- PUT/PATCH: 기존 객체를 업데이트할 때 사용
- DELETE: 기존 객체를 삭제할 때 사용
```
## HTTPS
- HyperText Transfer Protocol over Secure Socket Layer : TCP 대신 ```전송 계층 보안(TLS)``` 프로토콜을 기반으로 하는 HTTP.
- 네트워크로 암호화되지 않은 메시지를 주고받을 때는 제 3자가 메시지를 볼 수 있어서 민감한 데이터를 주고받으면 안된다. HTTPS를 사용하면 서버와 클라이언트가 주고받는 메시지를 암호화하여 제 3자가 볼 수 없다.
- 메시지를 암/복호화 할 때 사용하는 키는 HTTPS로 메시지를 주고받는 두 컴퓨터만 알기 때문에 암호화된 내용을 제 3자가 알 수 없다.
- HTTPS는 4계층에서 동작하는 TLS와 달리 7계층에서 동작한다.
- 웹 브라우저는  HTTPS 연결 과정에서 서버가 보낸 인증서를 받는다. 인증서가 신뢰할 수 있는 기관에서 인증한 게 아니거나 인증 기간이 만료됐다면 연결을 허용하지 않는다.
```
핸드셰이킹 과정
클라이언트    <->     서버
-> Client Hello 메시지 (랜덤값, 암호화 목록 등)
<- Server Hello 메시지 (서버 랜덤값, 공개키 포함한 인증서)
클라이언트: 인증서 검증
-> Premaster 키 생성 후 공개키로 암호화
서버: 비밀키로 복호화하여 Premaster 키 획득
클라이언트: 클라이언트 랜덤, 서버 랜덤, Premaster 키를 조합해 암호화 키 생성'
-> 검증 완료 및 암호화 통신 알림 메시지
서버: 클라이언트 랜덤, 서버 랜덤, Premaster 키를 조합해 암호화 키 생성
<- 검증 완료 및 암호화 통신 알림 메시지
```





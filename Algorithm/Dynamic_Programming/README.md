# Dynamic Programming (동적 프로그래밍)

동적 프로그래밍은 큰 문제의 해답에 작은 문제의 해답이 포함되어 있고, 이를 **재귀호출 알고리즘으로 구현하면 지나친 중복이 발생하는 경우**에 이 재귀적 중복을 해결하는 방법을 뜻한다.



- 피보나치 수

  ```mathematica
  f(n) = f(n-1) + f(n-2)
  f(1) = f(2) = 1
  ```

  즉, n의 피보나치 수는 n-1의 피보나치 수와 n-2의 피보나치 수를 포함하고 있다.



이처럼 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 **최적 부분 구조(Optional Substructure)**를 가졌다고 한다. 동적 프로그래밍을 적용하려면 문제가 일단 이 성질을 가져야 한다.

이런 최적 부분 구조를 가진 문제의 경우에는 재귀호출을 사용해 문제를 풀 수 있다. 피보나치 수 문제의 경우 fib(n)은 fib(n-1)과 fib(n-2)를 재귀적으로 호출한다.



- 피보나치 코드 예시 (재귀 함수)

  ```pseudocode
  fib(n){
  	if(n=1 or n=2)
  		then return 1;
  		else return (fib(n-1)+fib(n-2));
  }
  ```

  

최적 부분 구조는 문제의 해답을 구하기 위해 더 작은 문제의 해답을 이용하므로 이처럼 재귀적 알고리즘으로 구현하는 것이 자연스럽다. 그러나 재귀적 알고리즘은 때때로 엄청난 비효율을 초래할 수 있다. 문제의 크기가 커짐에 따라 중복 호출이 증가하는 경우가 있기 때문이다. 이런 경우, 한 번만 구해 저장해 놓았다가 나중에 사용만 하면 된다. **부분 결과를 저장하면서 해를 구해나가는 것이 동적 프로그래밍의 핵심이다.** 이렇게 재귀적으로 구현했을 때 중복 호출로 심각한 비효율이 발생하는 경우가 동적 프로그래밍을 사용하기 적합한 두 번째 조건이다.



동적 프로그래밍을 적용할 수 있는 문제의 성질을 정리해보면,

```smalltalk
1. **최적 부분 구조**를 이룬다.
2. 재귀적으로 구현했을 때 **중복 호출**로 심각한 비효율이 발생한다.
```





- 피보나치 코드 (동적 프로그래밍)

  ```pseudocode
  fib(n){
  	f[1] <- f[2] <- 1;
  	for i <- 3 to n
  		f[i] <- f[i-1]+f[i-2];
  	return f[n];
  }
  ```



for 루프를 순환하는 것이 수행 시간을 좌우하므로 선형 시간 알고리즘이다. 아래에서 위로 저장해나가면서 해를 구하는 방식이므로 바텀업 방식의 동적 프로그래밍이다.

또한 재귀함수를 이용하여 이미 계산하였는지 여부를 저장하여 비효율을 제거할 수도 있다. 중복된 재귀호출을 피하는 이런 방법의 동적 프로그래밍에는 특별히 **메모하기(Memoization)**라는 이름이 붙어있다. 메모이제이션은 탑다운 방식의 동적 프로그래밍으로 하향식 방법이다.



## 행렬 경로 문제

nxn 행렬이 주어졌을 때, 행렬의 왼쪽 위에서 시작해 한 칸씩 이동해 오른쪽 아래까지 도달하는 가장 큰 가중치의 경로를 구하는 문제에서 동적 프로그래밍을 사용할 수 있다.

모든 이동 경로를 방문하여 가장 높은 가중치를 구할 수 있으나 지수 함수적인 시간이 걸린다.

- 오른쪽이나 아래쪽으로 이동할 수 있다.
- 왼쪽, 위쪽, 대각선 이동은 허용하지 않는다.



행렬의 왼쪽 위 원소 (1,1) 에서 원소 (i,j) 까지 도달하는 경로들의 점수 중 최고점을 구하려고 할 때, 원소 (i,j) 에 도달하기 직전에 방문할 수 있는 원소는 (i-1,j) 와 (i,j-1) 두 개이다. 즉, (i-1,j) 와 (i,j-1) 중 가중치가 높은 쪽을 선택하여 원소 (i,j) 의 가중치를 더하면 원소 (i,j) 까지 도달하는 최고 점수를 구할 수 있다.

다시 말해 문제 (i,j)의 최적해는 문제 (i-1,j)의 최적해와 문제 (i,j-1)의 최적해로 구할 수 있다. 자신 부분 문제에 대한 최적해를 자신의 최적해를 구성하는 데 사용한다. -> **최적 부분 구조** 이다.



이 최적 부분 구조를 재귀적 관계로 나타내보면, 

```mathematica
c(i,j) = 0 -> if i=0 or j=0
         m(i,j) + max(c(i,j-1), c(i-1,j)) -> otherwise
```



이를 재귀 함수로 구현하면,

```pseudocode
martixPath(i,j){
	if(i=0 or j=0) then return 0;
	else return (m(i,j) + max(matrixPath(i-1,j), matrixPath(i,j-1))));
}
```

matrixPath(i,j) 에서 문제가 커질 수록 **중복 호출**이 지수 함수적으로 일어난다.



따라서 행렬 경로 문제는 동적 프로그래밍을 적용하기 좋은 문제이다. 이를 적용하여 구현하면,

```pseudocode
matrixPath(n){
	for i <- 0 to n
    	c[i,0] <- 0;
    for j <- 1 to n
    	c[0,j] <- 0;
   
    for i <- 1 to n
    	for j <- 1 to n
    		c[i,j] <- m[i,j] + max(c[i-1,j],c[i,j-1]);
    return c[n,n];
}
```



## 돌 놓기 문제

## 최장 공통 부분 순서


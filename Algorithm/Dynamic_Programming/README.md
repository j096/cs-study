# Dynamic Programming (동적 프로그래밍)

동적 프로그래밍은 큰 문제의 해답에 작은 문제의 해답이 포함되어 있고, 이를 **재귀호출 알고리즘으로 구현하면 지나친 중복이 발생하는 경우**에 이 재귀적 중복을 해결하는 방법을 뜻한다.



- 피보나치 수

  ```mathematica
  f(n) = f(n-1) + f(n-2)
  f(1) = f(2) = 1
  ```

  즉, n의 피보나치 수는 n-1의 피보나치 수와 n-2의 피보나치 수를 포함하고 있다.



이처럼 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 **최적 부분 구조(Optional Substructure)**를 가졌다고 한다. 동적 프로그래밍을 적용하려면 문제가 일단 이 성질을 가져야 한다.

이런 최적 부분 구조를 가진 문제의 경우에는 재귀호출을 사용해 문제를 풀 수 있다. 피보나치 수 문제의 경우 fib(n)은 fib(n-1)과 fib(n-2)를 재귀적으로 호출한다.



- 피보나치 코드 예시 (재귀 함수)

  ```pseudocode
  fib(n){
  	if(n=1 or n=2)
  		then return 1;
  		else return (fib(n-1)+fib(n-2));
  }
  ```

  

최적 부분 구조는 문제의 해답을 구하기 위해 더 작은 문제의 해답을 이용하므로 이처럼 재귀적 알고리즘으로 구현하는 것이 자연스럽다. 그러나 재귀적 알고리즘은 때때로 엄청난 비효율을 초래할 수 있다. 문제의 크기가 커짐에 따라 중복 호출이 증가하는 경우가 있기 때문이다. 이런 경우, 한 번만 구해 저장해 놓았다가 나중에 사용만 하면 된다. **부분 결과를 저장하면서 해를 구해나가는 것이 동적 프로그래밍의 핵심이다.** 이렇게 재귀적으로 구현했을 때 중복 호출로 심각한 비효율이 발생하는 경우가 동적 프로그래밍을 사용하기 적합한 두 번째 조건이다.



- 피보나치 코드 (동적 프로그래밍)

  ```pseudocode
  fib(n){
  	f[1] <- f[2] <- 1;
  	for i <- 3 to n
  		f[i] <- f[i-1]+f[i-2];
  	return f[n];
  }
  ```



for 루프를 순환하는 것이 수행 시간을 좌우하므로 선형 시간 알고리즘이다. 아래에서 위로 저장해나가면서 해를 구하는 방식이므로 바텀업 방식의 동적 프로그래밍이다.

또한 재귀함수를 이용하여 이미 계산하였는지 여부를 저장하여 비효율을 제거할 수도 있다. 중복된 재귀호출을 피하는 이런 방법의 동적 프로그래밍에는 특별히 **메모하기(Memoization)**라는 이름이 붙어있다. 메모이제이션은 탑다운 방식의 동적 프로그래밍으로 하향식 방법이다.



## 행렬 경로 문제

## 돌 놓기 문제

## 최장 공통 부분 순서


# 그리디 알고리즘 (Greedy Algorithm)

눈앞의 이익만 우선 추구하는 알고리즘을 총칭해서 그리디 알고리즘이라 한다. 하나의 온전한 해가 만들어질 때까지 눈앞에 가장 좋아보는 선택을 반복한다.

최소 신장 트리를 구할 때 그리디 알고리즘을 적용하면 최적해가 보장될 수 있다.



## 최적해가 보장되지 않는 경우

1. 이진 트리의 최적합 경로 찾기

   각 노드가 양의 가중치를 갖고 있는 이진 트리에서, 루트부터 시작해 왼쪽으로 분기할지 오른쪽으로 분기할지를 매 단계마다 결정해야 한다. 임의의 노드에 이르면 그제서야 그 노드의 자식에 할당된 가중치가 공개된다. 가중치의 최대 합을 구해야 할 때, 모든 노드를 다 확인하기 전에는 최적해를 보장할 수 없다. **가보지 않은 어떤 노드가 다른 모든 경로의 합보다 큰 가중치를 갖고 있을 가능성이 있기 때문이다.** 그러므로 이 문제는 [DFS](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/DFS)나 [BFS](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/BFS)와 같은 방식으로 모든 노드를 다 확인해보기 전에는 최적해를 보장할 수 없고, 수행 시간의 상한은 트리의 총 노드 수에 비례하게 된다.

2. 보따리 문제 (Knapsack Problem)

   부피가 m인 보따리와 이 보따리에 넣으려 하는 n개의 물건이 있다고 할 때, 물건 i의 부피는 w(i)이고 이것을 보따리 넣을 경우 p(i)의 가치가 있다. 물건들의 전체 부피 합이 m을 넘지 않도록 하면서 가치가 최대가 되도록 보따리에 물건을 넣는 방법을 찾아야 한다.

   이 문제를 그리디 알고리즘으로 구현하면, 물건을 단위 부피당 가치가 큰 순서(p(i)/w(i))로 정렬한 후 m을 넘기 전까지 보따리에 순차적으로 넣어주면 된다. 그러나 이 방식은 최적해를 보장하지 못한다. 이 문제는 NP-Hard에 속하는 난제이다. 만약 물건을 자를 수 있다면 그리디 알고리즘으로 최적해를 보장할 수 있다. 즉, 단위 부피당 가치가 가장 큰 물건 순서로 각 물건을 보따리에 추가하다가 어떤 물건을 넣으려는 순간 보따리 용량을 초과하면 남은 용량에 들어갈 만큼만 잘라넣으면 된다.

3. 동전 바꾸기

   동전의 종류와 전체 금액이 주어졌을 때, 전체 금액을 가장 적은 개수의 동전을 사용해 만드는 문제이다. 우리나라 동전의 경우처럼 동전의 액면이 커지면서 바로 아래 액면의 배수가 되는 경우에는 그리디한 방식으로 최적해를 구할 수 있다.(ex: 500원, 100원, 50원, 10원, 1원)

   그렇지만 동전의 액면이 증가하면서 앞 액면의 배수가 되지 않는 경우에는 그리디한 방법으로 최적해가 보장되지 않는다. (ex: 500원, 400원, 100원, 75원) 이러한 경우는 [동적 프로그래밍](https://github.com/j096/cs-study/tree/master/Algorithm/Dynamic_Programming)으로 최적해를 구할 수 있다.



## 최적해가 보장되는 경우

1. 최소 신장 트리 (Minimum Spanning Tree)

   [최소 신장 트리](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/Minimum_Spanning_Tree)를 위한 프림 알고리즘, 크루스칼 알고리즘은 그리디 알고리즘으로 최적해가 보장되는 예들이다.2.

2. 회의실 배정 문제

   여러 회의의  시작 시간과 종료 시간이 주어질 때, 1개의 회의실에서 가장 많은 수의 회의를 할 수 있는 방법을 구하는 문제이다.

   1. 종료 시간 오름차순으로 정렬한다. 알고리즘은 이 순서로 회의들을 포함시킬지 체크한다. 첫번째 회의는 무조건 선택된다.
   2. 바로 전에 선택된 회의 종료 시간과 현재 회의 시작 시간을 비교하여 현재 회의를 선택할 수 있는지 판단한다.
   3. 회의를 모두 확일할 때까지 2번을 반복한다.

3. [다익스트라 알고리즘](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/Shortest_Path#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-dijkstra-algorithm)

   

   

   

   


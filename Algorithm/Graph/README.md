# 그래프 (Grpah)
그래프는 현상이나 사물을 정점과 간선으로 표현하는 것으로, 정점(Vertex)은 대상이나 개체를 나타내고 간선(Edge)은 이들 간의 관계를 나타낸다. 간선은 방향과 가중치를 가질 수 있으며, 방향을 가진 그래프를 유향 그래프(Directed Graph), 방향이 없는 그래프를 무향 그래프(Undirected Graph) 라고 한다.

이런 다양한 그래프를 이용해 문제를 해결하는 알고리즘들이 있다.

n개의 정점 집합 V와 이들 간에 존재하는 간선의 집합 E로 구성된 그래프 G를 G=(V,E) 로 표시한다.



## 그래프의 표현

1. 인접 행렬을 이용한 방법

   1. G=(V,E) 에서 정점의 총수가 n이면, nxn 행렬을 준비한다. 

   2. 단순 그래프의 경우, 정점 i와 정점 j간에 간선이 있으면 행렬의 (i,j) 원소와 (j,i) 원소의 값을 1로 할당한다.

      가중치를 가진 무방향 그래프의 경우는 행렬에 1대신 가중치를 저장한다.

      가중치를 가진 유방향 그래프의 경우는 방향이 있는 행렬의 원소에만 가중치를 저장한다. (비대칭 행렬)

   3. 나머지 원소에는 0을 할당한다.

   

   행렬 표현법은 이해하기 쉽고 간선의 존재 여부를 즉가 알 수 있다는 장점이 있지만, nxn 행렬이 필요하므로 n^2에 비례하는 공간이 필요하고, 행렬의 모든 원소를 채우는데만 n^2에 비례하는 시간이 든다. 그러므로 O(n^2) 미만의 시간이 소요되는 알고리즘이 필요한 경우에 행렬 표현법을 사용하면 행렬의 준비 과정에서만 Θ(n^2)의 시간을 소모해버려 적절하지 않다.



2. 인접 리스트를 이용한 방법

   인접 리스트(Adjacency List) 표현법은 각 정점에 인접한 정점을 리스트로 표현하는 방법이다. 각 정점마다 리스트를 하나씩 만든다. 여러기에 각 정점에 인접한 정점들을 연결 리스트(Linked List)로 연결한다. **행렬 표현과 달리 존재하지 않는 간선은 표현상에 나타나지 않는다.**

   간선 하나에 대하여 <정점 번호, 다음 정점의 포인터> 로 구성된 노드가 2개씩 만들어진다. 정점 i와 정점 j가 인접하면 정점 i의 연결 리스트에 정점 j가, 정점 j의 연결리스트에 정점 i가 연결되어 한 간선당 노드가 2개씩 만들어지기 때문이다. 따라서 무향 그래프를 위한 인접 리스트 표현에서 필요한 총 노드 수는 존재하는 총 간선 수의 2배다.

   가중치를 가진 그래프의 경우는 노드에 <정점 번호, 가중치, 다음 정점의 포인터>를 저장한다.

   인접 리스트는 공간이 간선의 총수에 비례하는 양만큼 필요하므로 대체로 행렬 표현에 비해 공간의 낭비가 없다. 모든 가능한 정점 쌍에 비해 간선의 수가 적을 때 특히 유용하다. 그러나 **인접 리스트는 정점 i와 정점 j간에 간선이 존재하는지 알아볼 때 리스트에서 차례대로 훑어야 하므로 인접 행렬 표현보다는 시간이 많이 걸린다.** 그래서 인접 리스트 표현법은 간선의 밀도가 아주 높은 경우에는 그리 적합하지 않다.



3. 인접 배열

   인접 리스트처럼 간선의 수에 비례하는 공간을 쓰면서 간선의 존재 여부를 훨씬 빨리 체크할 수 있는 방법이 있다.

   각 정점에 연결된 정점들을 연결 리스트로 저장하는 대신 배열로 저장하면 연결 리스트의 포인터를 관리하는 번거로움이 없어지고, 두 정점의 인접 여부를 체크하는 시간도 줄일 수 있다.

   각 정점의 인접 배열 헤더에 인접 정점이 몇 개인지 표시해두면 탐색을 쉽게 할 수 있다. 또는 각 정점의 인접 배열을 위해 각 공간을 따로 할당받을 수도 있고, 전체 배열의 크기를 계산하여 하나의 배열을 할당받아 각 헤더에 자신의 인접 배열이 끝나는 인덱스를 표시해두어 사용할 수도 있다.



## 모든 정점을 방문하기 위한 알고리즘

- [BFS](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/BFS)
- [DFS](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/DFS)

## 가중치 그래프를 위한 알고리즘

### [최소 신장 트리](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/Minimum_Spanning_Tree)

### [최단 경로 구하기](https://github.com/j096/cs-study/tree/master/Algorithm/Graph/Shortest_Path)





